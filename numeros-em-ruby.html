<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
<head>
   <meta http-equiv="content-type" content="text/html; charset=utf-8" />
   <title>Números em Ruby</title>
   <meta name="author" content="" />

   <!--- Blueprint CSS Framework -->
   <link rel="stylesheet" href="css/blueprint/screen.css" type="text/css" media="screen, projection">
   <link rel="stylesheet" href="css/blueprint/print.css" type="text/css" media="print">
   <!--[if IE]>
      <link rel="stylesheet" href="css/blueprint/ie.css" type="text/css" media="screen, projection">
   <![endif]-->

   <!-- CodeRay syntax highlighting CSS -->
   <link rel="stylesheet" href="css/coderay.css" type="text/css" />

   <!-- Homepage CSS -->
   <link rel="stylesheet" href="css/site.css" type="text/css" media="screen, projection" />
</head>
<body>

<div class="container">

   <div class="column span-20 prepend-2 append-2 first last" id="header">
     <p class="title">Tutorial de Ruby do GURU-SP</p>
     <hr>
   </div>

   <div class="column span-15 prepend-2 first">
      <p class="title">Números em Ruby</p>
<p>Vamos brincar com números. Em Ruby, números sem pontos decimais são chamados inteiros (integers), e números com pontos decimais são geralmente chamados de números em ponto flutuante (floating-point numbers) ou, mais simples, floats (você deve inserir pelo menos um dígito depois do ponto decimal). Um literal inteiro é uma sequência simples de dígitos ex.: 0, 123, 123456789. Underscores podem ser inseridos em literais inteiros (embora não no começo ou no final), e essa característica é utilizada algumas vezes como separador de casa de milhar ex. 1_000_000_000. Caracteres do tip ounderscore são ignorados no dígito de string. Aqui está o programa <strong>p002numerosruby.rb</strong></p>
<div class="CodeRay">
<pre><span class="no"> 1</span> <span class="c"># p002numerosruby.rb</span>
<span class="no"> 2</span> <span class="c">=begin
<span class="no"> 3</span>  Números Ruby
<span class="no"> 4</span>  Operadores comuns:
<span class="no"> 5</span>  + adição
<span class="no"> 6</span>  - subtração
<span class="no"> 7</span>  * multiplicação
<span class="no"> 8</span>  / divisão
<span class="no"> 9</span> =end</span>
<span class="no"><strong>10</strong></span> 
<span class="no">11</span> puts <span class="i">1</span> + <span class="i">2</span>
<span class="no">12</span> puts <span class="i">2</span> * <span class="i">3</span>
<span class="no">13</span> <span class="c"># Divisão de inteiros</span>
<span class="no">14</span> <span class="c"># Quando você faz um cálculo aritmético com inteiros,</span>
<span class="no">15</span> <span class="c"># você receberá uma resposta em inteiros</span>
<span class="no">16</span> puts <span class="i">3</span> / <span class="i">2</span>
<span class="no">17</span> puts <span class="i">10</span> - <span class="i">11</span>
<span class="no">18</span> puts <span class="fl">1.5</span> / <span class="fl">2.6</span>
</pre>
</div>
<div class='box'>
<p>Inteiros Ruby são objetos da classe <strong>Fixnum</strong> ou <strong>Bignum</strong>. As classes <strong>Fixnum</strong> e <strong>Bignum</strong> representam inteiros de diferentes tamanhos. Ambas as classes descendem de <strong>Integer</strong> (e, sendo assim, de <strong>Numeric</strong>). Os números em ponto flutuantes são objetos da classe <strong>Float</strong>, correspondendo a arquitetura nativa do tipo de dados double. As classes <strong>Complex</strong>, <strong>BigDecimal</strong> e <strong>Rational</strong> não são embutidas no Ruby mas são distribuídas com ele como parte das bibliotecas padrões. Nós falaremos sobre classes em detalhes mais tarde.</p>
</div>
<p>A hierarquia das classes (cortesia: <a href="http://www.cs.mun.ca/%7Edonald">Donald Craig</a>) é como  a mostrada na figura abaixo:</p>
<p><img src="images/hierarquia_classes.gif" alt="" /></p>
<h2>Operadores e precedência</h2>
<p>Vamos dar uma olhada nos operadores do Ruby (cortesia: Dave Thomas &#8211; <a href="http://www.pragprog.com/titles/ruby3/programming-ruby-3">Programming Ruby</a>). Eles estão organizados aqui em ordem de precedência, da mais alta para a mais baixa.</p>
<table style="border:1px solid black;">
	<tr>
		<th>Método </th>
		<th>Operador </th>
		<th>Descrição </th>
	</tr>
	<tr>
		<td> Sim </td>
		<td> [] []= </td>
		<td> Referência a um elemento, conjunto de elementos </td>
	</tr>
	<tr>
		<td> Sim </td>
		<td> ** </td>
		<td> Exponenciação </td>
	</tr>
	<tr>
		<td> Sim </td>
		<td> ! ~ + &#8211; </td>
		<td> Não (negação), complemento, mais e menos unários (os nomes de métodos para os dois últimos são +@ e -@)</td>
	</tr>
	<tr>
		<td> Sim </td>
		<td> * / % </td>
		<td> Multiplicação, divisão e módulo </td>
	</tr>
	<tr>
		<td> Sim </td>
		<td> &gt;&gt; &lt;&lt; </td>
		<td> Deslocamento para direita e esquerda </td>
	</tr>
	<tr>
		<td> Sim </td>
		<td> &amp; </td>
		<td> &#8220;E&#8221; (bitwise par inteiros) </td>
	</tr>
	<tr>
		<td> Sim </td>
		<td> ^  </td>
		<td> &#8220;Ou&#8221; exclusivo e &#8220;ou&#8221; comum (bitwise par inteiros) </td>
	</tr>
	<tr>
		<td> Sim </td>
		<td> &lt;= &lt; &gt; &gt;= </td>
		<td> Operadores de comparação </td>
	</tr>
	<tr>
		<td> Sim </td>
		<td> &lt;= &lt; &gt; &gt;= </td>
		<td> Igualdade e operadores para casamento de padrões (!= e !~ não podem ser definidos como métodos) </td>
	</tr>
	<tr>
		<td>     </td>
		<td> &amp;&amp; </td>
		<td> &#8220;E&#8221; lógico </td>
	</tr>
	<tr>
		<td>     </td>
		<td>    </td>
		<td> &#8220;Ou&#8221; lógico </td>
	</tr>
	<tr>
		<td>     </td>
		<td> .. &#8230; </td>
		<td> Intervalos inclusivo e exclusivo </td>
	</tr>
	<tr>
		<td>     </td>
		<td> ?: </td>
		<td> Operador ternário (If-then-else) </td>
	</tr>
	<tr>
		<td>     </td>
		<td> = %= /= -= += = &amp;= &gt;&gt;= &lt;&lt;= <strong>= &amp;&amp;= = *</strong>= </td>
		<td> Operadores de atribuição </td>
	</tr>
	<tr>
		<td>     </td>
		<td> defined? </td>
		<td> Checa se um símbolo foi definido </td>
	</tr>
	<tr>
		<td>     </td>
		<td> not </td>
		<td> Negação lógica </td>
	</tr>
	<tr>
		<td>     </td>
		<td> or and </td>
		<td> Composição lógica</td>
	</tr>
	<tr>
		<td>     </td>
		<td> if unless while until </td>
		<td> Modificadores de expressão</td>
	</tr>
	<tr>
		<td>     </td>
		<td> begin/end </td>
		<td> Expressão de blocos</td>
	</tr>
</table>
<div class='box'>
<ol>
	<li>Os operadores de incremento e decremento (++ e &#8212;) não estão disponíveis em Ruby, nem da forma &#8220;pré&#8221; nem &#8220;pós&#8221;. Entretanto, note que os operadores += e -= estão disponíveis.</li>
	<li>Parênteses funcionam da mesma forma como em expressões aritméticas. Qualquer coisa dentro de parênteses é calculado primeiro (ou, de uma forma mais técnica, é dado uma precedência maior).</li>
	<li>Os operadores checados na figura são um tipo de <em>syntactic sugar</em> (&#8220;açúcar sintático&#8221;, mais sobre isso depois) &#8211; onde algo parece com um operador mas na verdade é uma chamada a um método.<br />
</div></li>
</ol>
<p>O operador módulo (%) do Ruby comportasse da seguinte forma:</p>
<div class="CodeRay">
<pre><span class="no">1</span> puts (<span class="i">5</span> % <span class="i">3</span>)     <span class="c"># imprime  2  </span>
<span class="no">2</span> puts (<span class="i">-5</span> % <span class="i">3</span>)    <span class="c"># imprime  1  </span>
<span class="no">3</span> puts (<span class="i">5</span> % <span class="i">-3</span>)    <span class="c"># imprime -1  </span>
<span class="no">4</span> puts (<span class="i">-5</span> % <span class="i">-3</span>)   <span class="c"># imprime -2 </span>
</pre>
</div>
<p>A definição do operador módulo do Ruby é diferente do C e do Java, -7%3 é 2. Em C e Java, o resultado é -1. Em Ruby, o sinal do resultado (para o operador %) é sempre o mesmo sinal que o do segundo operando.</p>
<h2>Diferença entre os operadores or e ||</h2>
<p>Ambos, <strong>or</strong> e <strong>||</strong>, retornam o primeiro argumento ao menos que este retorne <strong>false</strong>, neste caso avaliam e retornam o segundo argumento. Isto é demonstrado no exemplo seguinte:</p>
<div class="CodeRay">
<pre><span class="no">1</span> puts <span class="pc">nil</span> || <span class="i">2008</span>  
<span class="no">2</span> puts <span class="pc">false</span> || <span class="i">2008</span>  
<span class="no">3</span> puts <span class="s"><span class="dl">&quot;</span><span class="k">ruby</span><span class="dl">&quot;</span></span> || <span class="i">2008</span>
</pre>
</div>
<p>A saída é:</p>
<div class="CodeRay">
<pre><span class="no">1</span> &gt;ruby test.rb  
<span class="no">2</span> <span class="i">2008</span>  
<span class="no">3</span> <span class="i">2008</span>  
<span class="no">4</span> ruby  
<span class="no">5</span> &gt;<span class="co">Exit</span> code: <span class="i">0</span>
</pre>
</div>
<p>A única diferença entre <strong>or</strong> e <strong>||</strong> é sua precedência. <strong>||</strong> tem uma precedência mais alta do que <strong>or</strong>.</p>
<p>Uma prática comum é usar || para atribuir valor a uma variável somente se nenhum valor foi atribuído a ela. Isso pode ser escrito assim:</p>
<div class="CodeRay">
<pre><span class="no">1</span> <span class="iv">@variavel</span> = <span class="iv">@variavel</span> || <span class="s"><span class="dl">&quot;</span><span class="k">valor padrão</span><span class="dl">&quot;</span></span>
</pre>
</div>
<p>ou, mais idiomático, como:</p>
<div class="CodeRay">
<pre><span class="no">1</span> <span class="iv">@variavel</span> ||= <span class="s"><span class="dl">&quot;</span><span class="k">valor padrão</span><span class="dl">&quot;</span></span>
</pre>
</div>
<p>Uma razão para essas versões alternativas de operadores booleanos é o fato de que eles têm precedência mais baixa do que o operador de atribuição. Isto significa que você pode escrever uma expressão booleana como a seguinte que atribui valores à variáveis até que ele encontre um valor false:</p>
<div class="CodeRay">
<pre><span class="no">1</span> <span class="r">if</span> a = f(x) <span class="r">and</span> b = f(y) <span class="r">and</span> c = f(z) <span class="r">then</span> d = g(a,b,c) <span class="r">end</span>
</pre>
</div>
<p>Esta expressão simplesmente não funcionaria se escrita com <strong>&amp;&amp;</strong> ao invés de <strong>and</strong>.</p>
   </div>

   <div class="column span-5 append-2 last">

      <p><a href="http://www.guru-sp.org" title="Grupo de Usuários Ruby de SP"><img src="images/logo_guru-sp.jpg" title="Logo do GURU-SP" alt="Logo do Guru-SP" /></a></p>

      <div class="box">
         <p>Este material tem como base o <a href="http://www.rubylearning.com" title="Ruby Learning">tutorial do RubyLearning.com de Satish Talim</a> e foi traduzido por membros do <a href="http://www.guru-sp.org" title="Grupo de Usuários Ruby de SP">GURU-SP</a> com a permissão do autor.</p>
        <p class="last">Ajude o RubyLearning participando em algum dos <a href="http://www.rubylearning.org" title="cursos do Ruby Learning">cursos pagos</a> ou <a href="http://pledgie.com/campaigns/415" title="Ajude o Ruby Learning">fazendo uma doação para o projeto</a></p>
      </div>

      <p class="quiet"><a href="index.html" title="índice">Voltar para o índice</a></p>

      <h5></h5>
      <p class="incr"></p>
   </div>

   <div class="column span-20 prepend-2 append-2 first last" id="footer">
     <hr />
     <p>Tuturial de Ruby do <a href="http://www.guru-sp.org" title="Grupo de Usuários Ruby de SP">GURU-SP</a>. Este site foi criado com <a href="http://webby.rubyforge.org">Webby</a></p>
   </div>

</div>
</body>
</html>
